import os
import pdb
import sys
import h5py
import glob
import cycler
import numpy as np
from scipy import stats
import matplotlib as mpl
from matplotlib import rc
import matplotlib.pyplot as plt
from astropy.cosmology import FlatLambdaCDM
cosmo = FlatLambdaCDM(H0=71, Om0=0.220, Ob0=0.02258*(0.71**2), name='OuterRim')

sys.path.insert(0, "/Users/joe/repos/shearfit/shearfit")
from analytic_profiles import NFW
from astropy.cosmology import WMAP7
from lensing_system import obs_lens_system
from mass_concentration import child2018 as cm
from fit_profile import fit_nfw_profile_lstq as fit
from fit_profile import fit_nfw_profile_gridscan as fit_gs
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
    
def imscatter(x, y, image, ax=None, zoom=1):
    if ax is None:
        ax = plt.gca()
    try:
        image = plt.imread(image)
    except TypeError:
        # Likely already an array...
        pass
    im = OffsetImage(image, zoom=zoom)
    x, y = np.atleast_1d(x, y)
    artists = []
    for x0, y0 in zip(x, y):
        ab = AnnotationBbox(im, (x0, y0), xycoords='data', frameon=False)
        artists.append(ax.add_artist(ab))
    ax.update_datalim(np.column_stack([x, y]))
    ax.autoscale()
    return artists


# =================================================================================================
# =================================================================================================


class nfw_profile_fitter:

    def __init__(self, NFW_dir):
        """
        This class contains routines to perform an example run of the shearfit package, fitting an NFW profile 
        to background source data as obtained from ray-tracing through a pure NFW particle realization. The 
        process is as follows:
        1) sources positions, redshifts, and shears are read in from ray-tacing outputs
        4) an NFW profile is fit to the scaled tangential shear ΔΣ = γ_t * Σ_c, using three methods:
            - allow both the concentration and halo radius to float
            - only fit the halo radius, inferring the concentration from a c-M relation
            - do a grid scan over the parameter pair including radius and concentration
        
        Parameters
        ----------
        NFW_dir : string
            Path to an output directory generated by the modules in mpwl_raytrace/NFW_test_cases.
            This directory is assumed to contain an HDF5 file giving ray-traced maps, as well as a properties.csv
            file, containing the intrinsic halo properties from the simulation.
        """
        
        print('======= Initializing fitter object for dataset at {} ========'.format(halo_cutout_dir.split('/')[-1]))
        print('Finding lenses')
        zlpl_dirs = np.array(glob.glob('{}/halo*'.format(halo_cutout_dir)))
        zl = np.array([float(d.split('/')[-1].split('zl')[-1].split('_')[0]) for d in zlpl_dirs])
        zs = np.array([float(d.split('/')[-1].split('zs')[-1].split('_')[0]) for d in zlpl_dirs])
        N = np.array([float(d.split('/')[-1].split('N')[-1].split('_')[0]) for d in zlpl_dirs])
        rfrac = np.array([float(d.split('/')[-1].split('r200c')[0].split('_')[-1]) for d in zlpl_dirs])
        
        sort = np.argsort(zl)
        self.zlpl_dirs, self.zl, self.zs, self.N, self.rfrac = zlpl_dirs[sort], zl[sort], zs[sort], N[sort], rfrac[sort] 
        self.out_dir = '{}/profile_fits'.format(NFW_dir)

    
    # ------------------------------------------------------------------------------------------------------------


    def fit_halos(self, rmax = None, rmin = 0, single_halo_plots = False, bin_data=False, rbins=25, 
                  bootstrap=False, dont_skip_fit=False):
        """
       Use the shearfit package to fit the profiles of all halos present in NFW_dir, saving the resultinng differential
       surface mass profile and mass estimation to self.out_dir

        Parameters
        ----------
        rmax : float array, optional
            The maximum radial distance of sources to include in the fit in units of r200c (e.g. rmin = 2.0 will
            trim the source popiulation beyond 2*r200c. Defaults to None, in which case rmax will automatically be 
            set to the full radial extent of the FOV as given in the NFW input. This default will also be imposed if
            the input rmax is greater than the size of the FOV. If an array is provided, the entire fitting procedure
            will be done per array entry, varying the rmax "hyperparameter" 
        rmin : float array, optional
            The minimum radial distance of sources to include in the fit in units of r200c (e.g. rmin = 0.3 will
            remove the inner 300kpc/h of source information). Defaults to 0. If an array is provided, the entire 
            fitting procedure will be done per array entry, varying the rmin "hyperparameter" 
        single_halo_plots : boolean, optional
            Whether or not to render a profile fitting plot per-halo. If True, perform a  grid scan in addition to 
            the two profile fits to plot residuals over parameter space, saving plots to the class-wide output direcotry
            set in the constructor. If False, return after fit and skip parameter sweep, plot nothing. Defaults to False. 
        bin_data : bool, optional
            whether or not to fit to shears averaged in radial bins, rather than to each individual source.
            Defaults to False.
        rbins : int, optional
            Number of bins distribute over the radial range of the data, if bin_data == True. Defaults to 25.
        bootstrap : bool, optional
            Whether or not to run bootstrap error estimation on the fitted profiles. Defaults to False, which is much
            faster.
        dont_skip_fit : bool, optional
            whether or not to force running of profile fits, even if already exist. If False, then this function does 
            nothing in the case that profile fitting outputs are already present in self.out_dir. This is simply to allow
            calling code the convenience of not having to comment out this function call if plotting etc. needs to be 
            redone. Defaults to False.
        """

        # loop over all halos in input dir
        for i in range(len(self.zl)):
            print('\nreading lensing mock data for lens zl={}, zs={}, N={}, rfrac={}'.format(
                    self.zl[i], self.zs[i], self.N[i], self.rfrac[i]))
            
            # read lensing maps and scale rmin, rmax to Mpc
            [sim_lens, true_profile] = self._read_nfw_shears(self.zlpl_dirs[i])
            
            # loop over all chocies of rmin, rmax
            for j in range(len(rmin)):
                for k in range(len(rmax)):
                    if(rmax[k] is not None): this_rmax = true_profile.r200c * rmax[k]
                    this_rmin = true_profile.r200c * rmin[j]

                    self.output_suffix = 'zl{:.3f}_zs{:.3f}_N{}_fov{:.2f}_rmin{:.2f}_rmax{:.2f}'.format(
                                          zl[i], zs[i], N[i], rfrac[i], this_rmin, this_rmax)
                    
                    if(len(glob.glob('{}/*{}.npy'.format(self.out_dir, output_suffix))) == 0 or dont_skip_fit):
                        if not os.path.exists(self.out_dir): os.makedirs(self.out_dir)
                        self._fit_nfw(sim_lens, true_profile, rmin=this_rmin, rmax=this_rmax,
                                      make_plot=single_halo_plots, bin_data=bin_data, rbins=rbins, 
                                      bootstrap=bootstrap, sfx=output_suffix) 
        
    
    # ------------------------------------------------------------------------------------------------------------


    def _read_nfw_shears(self, halo_dir):
        """
        Reads the lensing data for a single halo as output by mpwl_raytrace. THe halo property information
        is loaded into a analytic_profiles.NFW object from shearfit, and the backgrouns source data (shears, etc)
        are loaded into a lensing_)system.obs_lens_system object from shearfit. Both of these objects are returned

        Parameters
        ----------
        halo_dir : string
            Top-level directory containing halo particle data and lensing maps

        Returns
        -------
        sim_lens : obs_lens_system object instance
            A shearfit obs_lens_system object, containing source positions, redshfits, and lensing quantities
        true_profile : NFW object instance
            A shearfit NFW object, containing true input halo properties (to compare fit result)
        """

        # get ray-trace hdf5 and properties csv
        rtfs = glob.glob('{}/lensing_maps_zs*/*mock*.hdf5'.format(halo_dir)) 
        pfs = glob.glob('{}/properties.csv'.format(halo_dir))
        assert len(pfs) == 1, "Exactly one properties file is expected in {}".format(halo_dir)

        # read lens properties from csv, source data from hdf5
        props_file = pfs[0]
        props = np.genfromtxt(props_file, delimiter=',', names=True)
        zl = props['halo_redshift']
        r200c = props['sod_halo_radius']
        c = props['sod_halo_cdelta']
        c_err = props['sod_halo_cdelta_error']
        m200c = props['sod_halo_mass']
        true_profile = NFW(r200c, c, zl, c_err = c_err, cosmo=cosmo)
 
        raytrace_file = h5py.File(rtfs[0], 'r')
        nplanes = len(list(raytrace_file.keys()))
        t1, t2, y1, y2, k, zs = [], [], [], [], [], []

        # stack data from each source plane
        for i in range(nplanes):
            plane_key = list(raytrace_file.keys())[i]
            plane = raytrace_file[plane_key]
            plane_z = plane['zs'][0]   

            #ignore this plane if infront of the halo
            if(plane_z < zl): continue
             
            y1 = np.hstack([y1, np.ravel(plane['shear1'][:])])
            y2 = np.hstack([y2, np.ravel(plane['shear2'][:])])
            t1 = np.hstack([t1, np.ravel(plane['x1'][:])])
            t2 = np.hstack([t2, np.ravel(plane['x2'][:])])
            k = np.hstack([k, np.ravel(plane['kappa0'][:])])
            zs = np.hstack([zs, np.ones(len(t1)-len(zs)) * plane_z])
        raytrace_file.close()
       
        # trim the fov borders by 10% to be safe
        mask = np.logical_and(np.abs(t1)<props['boxRadius_arcsec']*0.9, 
                              np.abs(t2)<props['boxRadius_arcsec']*0.9)
        t1 = t1[mask]
        t2 = t2[mask]
        zs = zs[mask]
        y1 = y1[mask]
        y2 = y2[mask]
        k = k[mask]
        
        sim_lens = obs_lens_system(zl)
        sim_lens.set_background(t1, t2, zs, y1=y1, y2=y2, k=k, rho=rho) 
        return [sim_lens, true_profile]

    
    # ------------------------------------------------------------------------------------------------------------
    

    def _fit_nfw(self, lens, true_profile, rmin, rmax, bin_data, r_bins, bootstrap, make_plot, sfx):
        """
        Calls the fitting routines in shearfit on the loaded data, saving the result to both numpy files and png figures

        Parameters
        ----------
        lens : obs_lens_system object instance
            A shearfit obs_lens_system object, containing source positions, redshfits, and lensing quantities
        true_profile : NFW object instance
            A shearfit NFW object, containing true input halo properties (to compare fit result)
        rmin : float
            The minimum radial distance of sources to include in the fit in Mpc (e.g. rmin = 0.3 will
            remove the inner 300kpc/h of source information). Defaults to 0.
        rmax : float
            The maximum radial distance of sources to include in the fit in Mpc (e.g. rmin = 2.0 will
            trim the source popiulation beyond 2*r200c. Defaults to None, in which case rmax will automatically be 
            set to the full radial extent of the FOV as given in the NFW input. This default will also be imposed if
            the input rmax is greater than the size of the FOV.
        bin_data : bool
            whether or not to fit to shears averaged in radial bins, rather than to each individual source.
            Defaults to False.
        rbins : int
            Number of bins distribute over the radial range of the data, if bin_data == True. Defaults to 25.
        bootstrap : bool
            Whether or not to run bootstrap error estimation on the fitted profiles. Defaults to False, which is much
            faster.
        make_plot : boolean
            Whether or not to render a profile fitting plot per-halo. If True, perform a  grid scan in addition to 
            the two profile fits to plot residuals over parameter space, saving plots to the class-wide output direcotry
            set in the constructor. If False, return after fit and skip parameter sweep, plot nothing. Defaults to False.
        sfx : string
           Suffix to append to end of output filenames (for marking halo uniqueness) 
        """

        zl = lens.zl
        
        # fit the concentration and radius
        print('fitting with floating concentration')
        fitted_profile = NFW(0.75, 3.0, zl)
        fit(lens, fitted_profile, r200_bounds = [0.1, 15], conc_bounds = [1, 10], rmin=rmin, rmax=rmax, 
            bootstrap=bootstrap, bin_data=bin_data, bins=rbins)
        if(bootstrap):
            [dSigma_fitted, dSigma_fitted_err] = fitted_profile.delta_sigma(rsamp, bootstrap=True)
        else:
            dSigma_fitted = fitted_profile.delta_sigma(rsamp, bootstrap=False)
            dSigma_fitted_err = np.zeros(len(dSigma_fitted))

        # and now do it again, iteratively using a c-M relation instead of fitting for c
        print('fitting with inferred c-M concentration')
        fitted_cm_profile = NFW(0.75, 3.0, zl)
        fit(lens, fitted_cm_profile, r200_bounds = [0.1, 15], cM_relation='child2018', rmin=rmin, rmax=rmax, 
            bootstrap=bootstrap, bin_data=bin_data, bins=rbins)
        if(bootstrap):
            [dSigma_fitted_cm, dSigma_fitted_cm_err] = fitted_cm_profile.delta_sigma(rsamp, bootstrap=True)
        else:
            dSigma_fitted_cm = fitted_cm_profile.delta_sigma(rsamp, bootstrap=False)
            dSigma_fitted_cm_err = np.zeros(len(dSigma_fitted_cm))
        
        # write out fitting result
        print('r200c_fit = {:.4f}; m200c_fit = {:.4e}; c_fit = {:.2f}'.format(
               fitted_profile.r200c, fitted_profile.radius_to_mass(), fitted_profile.c))
        print('r200c_cm = {:.4f}; m200c_cm = {:.4e}; c_cm = {:.2f}'.format(
               fitted_cm_profile.r200c, fitted_cm_profile.radius_to_mass(), fitted_cm_profile.c))
        print('r200c_true = {:.4f}; m200c_true = {:.4e}; c_true = {:.2f}'.format(r200c, m200c, c))
        
        # save fitted profiles
        np.save('{}/fitted_profile_{}.npy'.format(self.out_dir, sfx), fitted_profile)
        np.save('{}/cM_fitted_profile_{}.npy'.format(self.out_dir, sfx), fitted_cm_profile)
        np.save('{}/true_profile{}.npy'.format(self.out_dir, sfx), true_profile)

        if(not make_plot): return
        else: self._plot_halo_profile(lens, true_profile, rmin, rmax, 
                                      dSigma_fitted, dSigma_fitted_err, dSigma_fitted_cm, dSigma_fitted_cm_err, 
                                      bin_data, rbins, sfx)


    # ------------------------------------------------------------------------------------------------------------


    def _plot_halo_profile(lens, true_profile, rmin, rmax, dSigma_fitted, dSigma_fitted_err, dSigma_fitted_cm, 
                           dSigma_fitted_cm_err, bin_data, rbins, sfx):
        """
        Plots a single halo profile, with points per-source, the true proile, and both fit variants. Includes a 
        second panel with a parameter sweep colormap.

        Parameters
        ----------
        lens : obs_lens_system object instance
            A shearfit obs_lens_system object, containing source positions, redshfits, and lensing quantities
        true_profile : NFW object instance
            A shearfit NFW object, containing true input halo properties (to compare fit result)
        rmin : float
            The minimum radial distance of sources to include in the plot in Mpc (e.g. rmin = 0.3 will
            remove the inner 300kpc/h of source information). Defaults to 0.
        rmax : float
            The maximum radial distance of sources to include in the plot in Mpc (e.g. rmin = 2.0 will
            trim the source popiulation beyond 2*r200c. Defaults to None, in which case rmax will automatically be 
            set to the full radial extent of the FOV as given in the NFW input. This default will also be imposed if
            the input rmax is greater than the size of the FOV.
        dSigma_fitted : array
            profile fit result as returned by NFW.delta_sigma in shearfit
        dSigma_fitted_err : array
            error in dSigma_fitted
        dSigma_fitted_cm : array
            profile fit result as returned by NFW.delta_sigma in shearfit, where a c-M relation was provided
        dSigma_fitted_cm_err : array
            error in dSigma_fitted_cm
        bin_data : bool
            whether or not to fits were done with shears averaged in radial bins, rather than to each individual source.
            Defaults to False.
        rbins : int
            Number of bins used to perform passed fits over the radial range of the data, if bin_data == True. Defaults to 25.
        sfx : string
           Suffix to append to end of output filenames (for marking halo uniqueness)         
        """
        
        zl = lens.zl
        r200c = true_profile.r200c
        m200c = true_profile.radius_to_mass()
        c = true_profile.c
        bg = lens.get_background()
        sigmaCrit = lens.calc_sigma_crit()
        yt = bg['yt']
        r = bg['r']
        k = bg['k']
        zs = bg['zs']

        # do radius cuts and bin data
        print('doing radial masking and binning')
        if(rmax is None):
            radial_mask = (r >= rmin)
        else:
            radial_mask = np.logical_and(r >= rmin, r <= rmax)
        sigmaCrit = sigmaCrit[radial_mask]
        yt = yt[radial_mask]
        r = r[radial_mask]
        k = k[radial_mask]
        zs = zs[radial_mask]
        fit_var = yt*sigmaCrit # can change this to directly fir to surface density
        kk = k * sigmaCrit

        rsamp = np.linspace(min(r), max(r), 1000)
        dSigma_true = true_profile.delta_sigma(rsamp)
        e = true_profile.sigma(r)
        se = true_profile.delta_sigma(r)
        
        # get binned data
        binned_dsig = stats.binned_statistic(r, fit_var, statistic='mean', bins=rbins)
        binned_r = stats.binned_statistic(r, r, statistic='mean', bins=rbins)
        binned_kk = stats.binned_statistic(r, kk, statistic='mean', bins=rbins)
        binned_yt = stats.binned_statistic(r, yt, statistic='mean', bins=rbins)
        
        # now do a grid scan
        print('doing grid scan')
        gridscan_profile = NFW(0.75, 3.0, zl)
        grid_r_bounds = [0.01, 1.2]
        grid_c_bounds = [0.5, 10]
        [grid_pos, grid_res] = fit_gs(lens, gridscan_profile, r200_bounds = grid_r_bounds, conc_bounds = grid_c_bounds, 
                                      n=100, bin_data=bin_data, bins=rbins)
        
        # visualize results... 
        rc('text', usetex=True)
        color = plt.cm.plasma(np.linspace(0.2, 0.8, 3))
        mpl.rcParams['axes.prop_cycle'] = cycler.cycler('color', color)

        # plot sources vs truth and both fits
        f = plt.figure(figsize=(12,6))
        ax = f.add_subplot(121)
        rR = rsamp/r200c
        
        if(not bin_data):
            ax.loglog(r/r200c, fit_var, 'xk', 
                    label=r'$\gamma_{\mathrm{NFW}}\Sigma_c$', alpha=0.33)
        else:
            ax.plot(binned_r[0]/r200c, binned_dsig[0], '-xk', 
                    label=r'$\gamma_{\mathrm{NFW}} \Sigma_c$')
        
        ax.plot(rR, dSigma_true, '--', label=r'$\Delta\Sigma_\mathrm{{NFW}},\>\>r_{{200c}}={:.3f}; c={:.3f}$'\
                                                .format(r200c, c), color=color[0], lw=2)
        ax.plot(rR, dSigma_fitted, label=r'$\Delta\Sigma_\mathrm{{fit}},\>\>r_{{200c}}={:.3f}; c={:.3f}$'\
                                            .format(fitted_profile.r200c, fitted_profile.c), color=color[1], lw=2)
        ax.plot(rR, dSigma_fitted_cm, label=r'$\Delta\Sigma_{{\mathrm{{fit}},c-M}},\>\>r_{{200c}}={:.3f}; c={:.3f}$'\
                                               .format(fitted_cm_profile.r200c, fitted_cm_profile.c), 
                                               color=color[2], lw=2)
        ax.fill_between(rR, dSigma_fitted - dSigma_fitted_err.T[0], 
                               dSigma_fitted + dSigma_fitted_err.T[1], 
                               color=color[1], alpha=0.2, lw=0)
        ax.fill_between(rR, dSigma_fitted_cm - dSigma_fitted_cm_err.T[0], 
                               dSigma_fitted_cm + dSigma_fitted_cm_err.T[1], 
                               color=color[2], alpha=0.33, lw=0)

        # format
        ax.legend(fontsize=12, loc='best')
        ax.set_xlabel(r'$r/R_{200c}$', fontsize=14)
        ax.set_ylabel(r'$\Delta\Sigma\>\>\lbrack\mathrm{M}_\odot\mathrm{pc}^{-2}\rbrack$', fontsize=14)
        ax.set_title(r'$z_\mathrm{{lens}} = {}$'.format(zl), fontsize=14)

        # plot fit cost in the radius-concentration plane
        ax2 = f.add_subplot(122)
        chi2 = ax2.pcolormesh(grid_pos[0], grid_pos[1], (1/grid_res)/(np.max(1/grid_res)), cmap='plasma')
        ax2.plot([r200c], [c], 'xw', ms=10, mew=1)
        ax2.plot([r200c], [c], 'xk', ms=10, label=r'$\mathrm{{truth}}$')
        ax2.errorbar(fitted_profile.r200c, fitted_profile.c, 
                     xerr=fitted_profile.r200c_err, yerr=fitted_profile.c_err, 
                     ms=10, marker='.', c=color[1], label=r'$\mathrm{{fit}}$')
        ax2.errorbar(fitted_cm_profile.r200c, fitted_cm_profile.c, 
                     xerr=fitted_cm_profile.r200c_err, yerr=fitted_cm_profile.c_err, 
                     ms=10, marker='.', c=color[2], label=r'${\mathrm{{fit\>w/}c\mathrm{-}M}}$')

        # include c-M relation curve
        tmp_profile = NFW(1,1,zl)
        tmp_m200c = np.zeros(len(grid_pos[0][0]))
        for i in range(len(tmp_m200c)):
            tmp_profile.r200c = grid_pos[0][0][i]
            tmp_m200c[i] = tmp_profile.radius_to_mass()
        tmp_c, tmp_dc = cm(tmp_m200c, zl, cosmo)
        ax2.plot(grid_pos[0][0], tmp_c, '--k', lw=2, label=r'$c\mathrm{-}M\mathrm{\>relation\>(Child+2018)}$')
        ax2.fill_between(grid_pos[0][0], tmp_c - tmp_dc, tmp_c + tmp_dc, color='k', alpha=0.1, lw=0)

        # format
        ax2.set_xlim(grid_r_bounds)
        ax2.set_ylim(grid_c_bounds)
        ax2.legend(fontsize=12, loc='upper right')
        cbar = f.colorbar(chi2, ax=ax2)
        cbar.set_label(r'$\mathrm{min}(\chi^2)/\chi^2$', fontsize=14)
        ax2.set_xlabel(r'$R_{200c}\>\>\left[\mathrm{Mpc}\right]$', fontsize=14)
        ax2.set_ylabel(r'$c_{200c}$', fontsize=14)
        ax.set_xlim([0.2, 6])
        ax.set_ylim([2, 300])
        plt.tight_layout() 

        if(bin_data): binstr = '_{}bins_'.format(rbins)
        else: binstr = '_'
        f.savefig('{}/shearprof_fit{}{}rmin_{}.png'.format(
                   self.ut_dir, binstr, rmin, sfx), dpi=300)
    
        
    # ------------------------------------------------------------------------------------------------------------


    def plot_convergence_results_mass(self, vary_var):
        '''
        Plot the mass estimated from many runs of fit_halos(), results of which are found in self.out_dir

        Parameters
        ---------
        vary_var : string
            which variable to plot convergence with respect to. This should be one of the quantities given in the 
            output directory suffix as defined in fit_halos(). Choices are: zl, zs, N, fov, rmin, rmax. It is 
            assumed that user has ensured that all output subdirs in self.out_dir have only one of these variables
            changing, to make for a meaningul convergence study.
        '''
        
        fit_out = glob.glob('{}/fitted_profile*.npy'.format(self.out_dir))
        m = np.array([np.load(f).radius_to_mass() for f in fit_out])
        cmfit_out = glob.glob('{}/cM_fitted_profile*.npy'.format(self.out_dir))
        m_cm = np.array([np.load(f).radius_to_mass() for f in cmfit_out])
        truth_out = glob.glob('{}/true*.npy'.format(self.out_dir))
        m_true = np.array([np.load(f)i.radius_to_mass() for f in truth_out])
        
        vary_val_m = np.array([float(f.split('/')[-1].split(vary_var)[-1].split('_')[0].strip('.npy')) 
                               for f in fit_out])
        vary_val_cm = np.array([float(f.split('/')[-1].split(vary_var)[-1].split('_')[0].strip('.npy')) 
                                for f in cmfit_out])
        vary_val_truth = np.array([float(f.split('/')[-1].split(vary_var)[-1].split('_')[0].strip('.npy')) 
                                   for f in truth_out])
        sm = np.argsort(vary_val_m)
        scm = np.argsort(vary_val_cm)
        st = np.argsort(vary_val_truth)
 
        f = plt.figure()
        ax = f.add_subplot(111)
        ax.plot(vary_val_truth[st], m_true[st]/m_true[st], '--k', label="truth")
        ax.plot(vary_val_m[sm], m[sm]/m_true[st], '-dr', label="unconstrained fit")
        ax.plot(vary_val_cm[scm], m_cm[scm]/m_true[st], '-db', label="c-M relation fit")

        var_strs = {'zl',r'$z_l$', 'zs':r'$z_s$', 'N':r'$\mathrm{particle\>count}$', 
                    'fov':r'$\mathrm{fov\>size/extent\>of\>particle generation$', 'rmin':r'$r_{\mathrm{fit,min}}$', 
                    'rmax':r'$r_{\mathrm{fit,max}}$'}

        ax.set_xlabel(vary_strs[vary_var], fontsize=14)
        ax.set_ylabel(r'$m_{200c,\mathrm{fit}} / m_{200c,\mathrm{truth}}$', fontsize=14)
        ax.legend()
        plt.savefig('convergence_tests/{}_convergence_mass2.png'.format(vary_var), dpi=300)




if(__name__ == "__main__"):
   
    # turn to true to force overwrite pre-existing fits
    dont_skip_fit = False
    
    # run all convergence tests
    fitter = nfw_profile_fitter(NFW_dir = '/Users/joe/repos/repo_user/nfw_lensing_runs/output2/vary_rmax')
    fitter.fit_halos(rmax=None, rmin=0.2, single_halo_plot=True, dont_skip_fit=dont_skip_fit)
    fitter.plot_convergnce_results_mass(cary_var='rmax')

